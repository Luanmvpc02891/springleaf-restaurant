/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { distinctUntilChanged } from 'rxjs/operators';
import { NgRedux } from '../components/ng-redux';
/**
 * Used with the `\@WithSubStore` class decorator to define a SubStore (AKA a
 * fractal store).
 *
 * For more info on substores, see
 * https://github.com/angular-redux/platform/blob/master/packages/store/articles/fractal-store.md
 * @record
 */
export function FractalStoreOptions() { }
if (false) {
    /**
     * The name of an instance method that will define the
     * base path for the subStore. This method is expected to return an array
     * of property names or undefined/null.
     * @type {?}
     */
    FractalStoreOptions.prototype.basePathMethodName;
    /**
     * The localReducer for the substore in question.
     * @type {?}
     */
    FractalStoreOptions.prototype.localReducer;
}
/**
 * OPTIONS_KEY: this is per-class (static) and holds the config from the
 * \@SubStore decorator.
 * @type {?}
 */
const OPTIONS_KEY = '@angular-redux::substore::class::options';
/**
 * INSTANCE_SUBSTORE_KEY, INSTANCE_SELECTIONS_KEY: these are per-instance
 * (non-static) and holds references to the substores/selected observables
 * to be used by an instance of a decorated class. I'm not using
 * reflect-metadata here because I want
 *
 * 1. different instances to have different substores in the case where
 * `basePathMethodName` is dynamic.
 * 2. the instance substore to be garbage collected when the instance is no
 * longer reachable.
 * This is therefore an own-property on the actual instance of the decorated
 * class.
 * @type {?}
 */
const INSTANCE_SUBSTORE_KEY = '@angular-redux::substore::instance::store';
/** @type {?} */
const INSTANCE_SELECTIONS_KEY = '@angular-redux::substore::instance::selections';
/**
 * Used to detect when the base path changes - this allows components to
 * dynamically adjust their selections if necessary.
 * @type {?}
 */
const INSTANCE_BASE_PATH_KEY = '@angular-redux::substore::instance::basepath';
/** @type {?} */
const getClassOptions = (decoratedInstance) => decoratedInstance.constructor[OPTIONS_KEY];
const ɵ0 = getClassOptions;
/**
 * @hidden
 * @type {?}
 */
export const setClassOptions = (decoratedClassConstructor, options) => {
    decoratedClassConstructor[OPTIONS_KEY] = options;
};
// I want the store to be saved on the actual instance so
// 1. different instances can have distinct substores if necessary
// 2. the substore/selections will be marked for garbage collection when the
//    instance is destroyed.
/** @type {?} */
const setInstanceStore = (decoratedInstance, store) => (decoratedInstance[INSTANCE_SUBSTORE_KEY] = store);
const ɵ1 = setInstanceStore;
/** @type {?} */
const getInstanceStore = (decoratedInstance) => decoratedInstance[INSTANCE_SUBSTORE_KEY];
const ɵ2 = getInstanceStore;
/** @type {?} */
const getInstanceSelectionMap = (decoratedInstance) => {
    /** @type {?} */
    const map = decoratedInstance[INSTANCE_SELECTIONS_KEY] || {};
    decoratedInstance[INSTANCE_SELECTIONS_KEY] = map;
    return map;
};
const ɵ3 = getInstanceSelectionMap;
/** @type {?} */
const hasBasePathChanged = (decoratedInstance, basePath) => decoratedInstance[INSTANCE_BASE_PATH_KEY] !== (basePath || []).toString();
const ɵ4 = hasBasePathChanged;
/** @type {?} */
const setInstanceBasePath = (decoratedInstance, basePath) => {
    decoratedInstance[INSTANCE_BASE_PATH_KEY] = (basePath || []).toString();
};
const ɵ5 = setInstanceBasePath;
/** @type {?} */
const clearInstanceState = (decoratedInstance) => {
    decoratedInstance[INSTANCE_SELECTIONS_KEY] = null;
    decoratedInstance[INSTANCE_SUBSTORE_KEY] = null;
    decoratedInstance[INSTANCE_BASE_PATH_KEY] = null;
};
const ɵ6 = clearInstanceState;
/**
 * Gets the store associated with a decorated instance (e.g. a
 * component or service)
 * @hidden
 * @type {?}
 */
export const getBaseStore = (decoratedInstance) => {
    // The root store hasn't been set up yet.
    if (!NgRedux.instance) {
        return undefined;
    }
    /** @type {?} */
    const options = getClassOptions(decoratedInstance);
    // This is not decorated with `@WithSubStore`. Return the root store.
    if (!options) {
        return NgRedux.instance;
    }
    // Dynamic base path support:
    /** @type {?} */
    const basePath = decoratedInstance[options.basePathMethodName]();
    if (hasBasePathChanged(decoratedInstance, basePath)) {
        clearInstanceState(decoratedInstance);
        setInstanceBasePath(decoratedInstance, basePath);
    }
    if (!basePath) {
        return NgRedux.instance;
    }
    /** @type {?} */
    const store = getInstanceStore(decoratedInstance);
    if (!store) {
        setInstanceStore(decoratedInstance, NgRedux.instance.configureSubStore(basePath, options.localReducer));
    }
    return getInstanceStore(decoratedInstance);
};
/**
 * Creates an Observable from the given selection parameters,
 * rooted at decoratedInstance's store, and caches it on the
 * instance for future use.
 * @hidden
 * @type {?}
 */
export const getInstanceSelection = (decoratedInstance, key, selector, transformer, comparator) => {
    /** @type {?} */
    const store = getBaseStore(decoratedInstance);
    if (store) {
        /** @type {?} */
        const selections = getInstanceSelectionMap(decoratedInstance);
        selections[key] =
            selections[key] ||
                (!transformer
                    ? store.select(selector, comparator)
                    : store.select(selector).pipe(obs$ => transformer(obs$, decoratedInstance), distinctUntilChanged(comparator)));
        return selections[key];
    }
    return undefined;
};
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXJlZHV4L3N0b3JlLyIsInNvdXJjZXMiOlsiZGVjb3JhdG9ycy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7Ozs7Ozs7OztBQWdCakQseUNBWUM7Ozs7Ozs7O0lBTkMsaURBQTJCOzs7OztJQUszQiwyQ0FBc0M7Ozs7Ozs7TUFPbEMsV0FBVyxHQUFHLDBDQUEwQzs7Ozs7Ozs7Ozs7Ozs7O01BZXhELHFCQUFxQixHQUFHLDJDQUEyQzs7TUFDbkUsdUJBQXVCLEdBQzNCLGdEQUFnRDs7Ozs7O01BTTVDLHNCQUFzQixHQUFHLDhDQUE4Qzs7TUFFdkUsZUFBZSxHQUFHLENBQUMsaUJBQXNCLEVBQXVCLEVBQUUsQ0FDdEUsaUJBQWlCLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQzs7Ozs7O0FBRzVDLE1BQU0sT0FBTyxlQUFlLEdBQUcsQ0FDN0IseUJBQThCLEVBQzlCLE9BQTRCLEVBQ3RCLEVBQUU7SUFDUix5QkFBeUIsQ0FBQyxXQUFXLENBQUMsR0FBRyxPQUFPLENBQUM7QUFDbkQsQ0FBQzs7Ozs7O01BTUssZ0JBQWdCLEdBQUcsQ0FDdkIsaUJBQXNCLEVBQ3RCLEtBQTRCLEVBQzVCLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLHFCQUFxQixDQUFDLEdBQUcsS0FBSyxDQUFDOzs7TUFFakQsZ0JBQWdCLEdBQUcsQ0FBQyxpQkFBc0IsRUFBd0IsRUFBRSxDQUN4RSxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQzs7O01BRXBDLHVCQUF1QixHQUFHLENBQUMsaUJBQXNCLEVBQUUsRUFBRTs7VUFDbkQsR0FBRyxHQUFHLGlCQUFpQixDQUFDLHVCQUF1QixDQUFDLElBQUksRUFBRTtJQUM1RCxpQkFBaUIsQ0FBQyx1QkFB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LCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbnlBY3Rpb24sIFJlZHVjZXIgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5nUmVkdXggfSBmcm9tICcuLi9jb21wb25lbnRzL25nLXJlZHV4JztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvb2JzZXJ2YWJsZS1zdG9yZSc7XG5pbXBvcnQge1xuICBDb21wYXJhdG9yLFxuICBQYXRoU2VsZWN0b3IsXG4gIFNlbGVjdG9yLFxuICBUcmFuc2Zvcm1lcixcbn0gZnJvbSAnLi4vY29tcG9uZW50cy9zZWxlY3RvcnMnO1xuXG4vKipcbiAqIFVzZWQgd2l0aCB0aGUgYEBXaXRoU3ViU3RvcmVgIGNsYXNzIGRlY29yYXRvciB0byBkZWZpbmUgYSBTdWJTdG9yZSAoQUtBIGFcbiAqIGZyYWN0YWwgc3RvcmUpLlxuICpcbiAqIEZvciBtb3JlIGluZm8gb24gc3Vic3RvcmVzLCBzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXJlZHV4L3BsYXRmb3JtL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3N0b3JlL2FydGljbGVzL2ZyYWN0YWwtc3RvcmUubWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGcmFjdGFsU3RvcmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIGFuIGluc3RhbmNlIG1ldGhvZCB0aGF0IHdpbGwgZGVmaW5lIHRoZVxuICAgKiBiYXNlIHBhdGggZm9yIHRoZSBzdWJTdG9yZS4gVGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5XG4gICAqIG9mIHByb3BlcnR5IG5hbWVzIG9yIHVuZGVmaW5lZC9udWxsLlxuICAgKi9cbiAgYmFzZVBhdGhNZXRob2ROYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbFJlZHVjZXIgZm9yIHRoZSBzdWJzdG9yZSBpbiBxdWVzdGlvbi5cbiAgICovXG4gIGxvY2FsUmVkdWNlcjogUmVkdWNlcjxhbnksIEFueUFjdGlvbj47XG59XG5cbi8qKlxuICogT1BUSU9OU19LRVk6IHRoaXMgaXMgcGVyLWNsYXNzIChzdGF0aWMpIGFuZCBob2xkcyB0aGUgY29uZmlnIGZyb20gdGhlXG4gKiBAU3ViU3RvcmUgZGVjb3JhdG9yLlxuICovXG5jb25zdCBPUFRJT05TX0tFWSA9ICdAYW5ndWxhci1yZWR1eDo6c3Vic3RvcmU6OmNsYXNzOjpvcHRpb25zJztcblxuLyoqXG4gKiBJTlNUQU5DRV9TVUJTVE9SRV9LRVksIElOU1RBTkNFX1NFTEVDVElPTlNfS0VZOiB0aGVzZSBhcmUgcGVyLWluc3RhbmNlXG4gKiAobm9uLXN0YXRpYykgYW5kIGhvbGRzIHJlZmVyZW5jZXMgdG8gdGhlIHN1YnN0b3Jlcy9zZWxlY3RlZCBvYnNlcnZhYmxlc1xuICogdG8gYmUgdXNlZCBieSBhbiBpbnN0YW5jZSBvZiBhIGRlY29yYXRlZCBjbGFzcy4gSSdtIG5vdCB1c2luZ1xuICogcmVmbGVjdC1tZXRhZGF0YSBoZXJlIGJlY2F1c2UgSSB3YW50XG4gKlxuICogMS4gZGlmZmVyZW50IGluc3RhbmNlcyB0byBoYXZlIGRpZmZlcmVudCBzdWJzdG9yZXMgaW4gdGhlIGNhc2Ugd2hlcmVcbiAqIGBiYXNlUGF0aE1ldGhvZE5hbWVgIGlzIGR5bmFtaWMuXG4gKiAyLiB0aGUgaW5zdGFuY2Ugc3Vic3RvcmUgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgd2hlbiB0aGUgaW5zdGFuY2UgaXMgbm9cbiAqIGxvbmdlciByZWFjaGFibGUuXG4gKiBUaGlzIGlzIHRoZXJlZm9yZSBhbiBvd24tcHJvcGVydHkgb24gdGhlIGFjdHVhbCBpbnN0YW5jZSBvZiB0aGUgZGVjb3JhdGVkXG4gKiBjbGFzcy5cbiAqL1xuY29uc3QgSU5TVEFOQ0VfU1VCU1RPUkVfS0VZID0gJ0Bhbmd1bGFyLXJlZHV4OjpzdWJzdG9yZTo6aW5zdGFuY2U6OnN0b3JlJztcbmNvbnN0IElOU1RBTkNFX1NFTEVDVElPTlNfS0VZID1cbiAgJ0Bhbmd1bGFyLXJlZHV4OjpzdWJzdG9yZTo6aW5zdGFuY2U6OnNlbGVjdGlvbnMnO1xuXG4vKipcbiAqIFVzZWQgdG8gZGV0ZWN0IHdoZW4gdGhlIGJhc2UgcGF0aCBjaGFuZ2VzIC0gdGhpcyBhbGxvd3MgY29tcG9uZW50cyB0b1xuICogZHluYW1pY2FsbHkgYWRqdXN0IHRoZWlyIHNlbGVjdGlvbnMgaWYgbmVjZXNzYXJ5LlxuICovXG5jb25zdCBJTlNUQU5DRV9CQVNFX1BBVEhfS0VZID0gJ0Bhbmd1bGFyLXJlZHV4OjpzdWJzdG9yZTo6aW5zdGFuY2U6OmJhc2VwYXRoJztcblxuY29uc3QgZ2V0Q2xhc3NPcHRpb25zID0gKGRlY29yYXRlZEluc3RhbmNlOiBhbnkpOiBGcmFjdGFsU3RvcmVPcHRpb25zID0+XG4gIGRlY29yYXRlZEluc3RhbmNlLmNvbnN0cnVjdG9yW09QVElPTlNfS0VZXTtcblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBjb25zdCBzZXRDbGFzc09wdGlvbnMgPSAoXG4gIGRlY29yYXRlZENsYXNzQ29uc3RydWN0b3I6IGFueSxcbiAgb3B0aW9uczogRnJhY3RhbFN0b3JlT3B0aW9ucyxcbik6IHZvaWQgPT4ge1xuICBkZWNvcmF0ZWRDbGFzc0NvbnN0cnVjdG9yW09QVElPTlNfS0VZXSA9IG9wdGlvbnM7XG59O1xuXG4vLyBJIHdhbnQgdGhlIHN0b3JlIHRvIGJlIHNhdmVkIG9uIHRoZSBhY3R1YWwgaW5zdGFuY2Ugc29cbi8vIDEuIGRpZmZlcmVudCBpbnN0YW5jZXMgY2FuIGhhdmUgZGlzdGluY3Qgc3Vic3RvcmVzIGlmIG5lY2Vzc2FyeVxuLy8gMi4gdGhlIHN1YnN0b3JlL3NlbGVjdGlvbnMgd2lsbCBiZSBtYXJrZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiB3aGVuIHRoZVxuLy8gICAgaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuY29uc3Qgc2V0SW5zdGFuY2VTdG9yZSA9IChcbiAgZGVjb3JhdGVkSW5zdGFuY2U6IGFueSxcbiAgc3RvcmU/OiBPYnNlcnZhYmxlU3RvcmU8YW55PixcbikgPT4gKGRlY29yYXRlZEluc3RhbmNlW0lOU1RBTkNFX1NVQlNUT1JFX0tFWV0gPSBzdG9yZSk7XG5cbmNvbnN0IGdldEluc3RhbmNlU3RvcmUgPSAoZGVjb3JhdGVkSW5zdGFuY2U6IGFueSk6IE9ic2VydmFibGVTdG9yZTxhbnk+ID0+XG4gIGRlY29yYXRlZEluc3RhbmNlW0lOU1RBTkNFX1NVQlNUT1JFX0tFWV07XG5cbmNvbnN0IGdldEluc3RhbmNlU2VsZWN0aW9uTWFwID0gKGRlY29yYXRlZEluc3RhbmNlOiBhbnkpID0+IHtcbiAgY29uc3QgbWFwID0gZGVjb3JhdGVkSW5zdGFuY2VbSU5TVEFOQ0VfU0VMRUNUSU9OU19LRVldIHx8IHt9O1xuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9TRUxFQ1RJT05TX0tFWV0gPSBtYXA7XG4gIHJldHVybiBtYXA7XG59O1xuXG5jb25zdCBoYXNCYXNlUGF0aENoYW5nZWQgPSAoXG4gIGRlY29yYXRlZEluc3RhbmNlOiBhbnksXG4gIGJhc2VQYXRoPzogUGF0aFNlbGVjdG9yLFxuKTogYm9vbGVhbiA9PlxuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9CQVNFX1BBVEhfS0VZXSAhPT0gKGJhc2VQYXRoIHx8IFtdKS50b1N0cmluZygpO1xuXG5jb25zdCBzZXRJbnN0YW5jZUJhc2VQYXRoID0gKFxuICBkZWNvcmF0ZWRJbnN0YW5jZTogYW55LFxuICBiYXNlUGF0aD86IFBhdGhTZWxlY3Rvcixcbik6IHZvaWQgPT4ge1xuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9CQVNFX1BBVEhfS0VZXSA9IChiYXNlUGF0aCB8fCBbXSkudG9TdHJpbmcoKTtcbn07XG5cbmNvbnN0IGNsZWFySW5zdGFuY2VTdGF0ZSA9IChkZWNvcmF0ZWRJbnN0YW5jZTogYW55KSA9PiB7XG4gIGRlY29yYXRlZEluc3RhbmNlW0lOU1RBTkNFX1NFTEVDVElPTlNfS0VZXSA9IG51bGw7XG4gIGRlY29yYXRlZEluc3RhbmNlW0lOU1RBTkNFX1NVQlNUT1JFX0tFWV0gPSBudWxsO1xuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9CQVNFX1BBVEhfS0VZXSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHN0b3JlIGFzc29jaWF0ZWQgd2l0aCBhIGRlY29yYXRlZCBpbnN0YW5jZSAoZS5nLiBhXG4gKiBjb21wb25lbnQgb3Igc2VydmljZSlcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJhc2VTdG9yZSA9IChcbiAgZGVjb3JhdGVkSW5zdGFuY2U6IGFueSxcbik6IE9ic2VydmFibGVTdG9yZTxhbnk+IHwgdW5kZWZpbmVkID0+IHtcbiAgLy8gVGhlIHJvb3Qgc3RvcmUgaGFzbid0IGJlZW4gc2V0IHVwIHlldC5cbiAgaWYgKCFOZ1JlZHV4Lmluc3RhbmNlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBnZXRDbGFzc09wdGlvbnMoZGVjb3JhdGVkSW5zdGFuY2UpO1xuXG4gIC8vIFRoaXMgaXMgbm90IGRlY29yYXRlZCB3aXRoIGBAV2l0aFN1YlN0b3JlYC4gUmV0dXJuIHRoZSByb290IHN0b3JlLlxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gTmdSZWR1eC5pbnN0YW5jZTtcbiAgfVxuXG4gIC8vIER5bmFtaWMgYmFzZSBwYXRoIHN1cHBvcnQ6XG4gIGNvbnN0IGJhc2VQYXRoID0gZGVjb3JhdGVkSW5zdGFuY2Vbb3B0aW9ucy5iYXNlUGF0aE1ldGhvZE5hbWVdKCk7XG4gIGlmIChoYXNCYXNlUGF0aENoYW5nZWQoZGVjb3JhdGVkSW5zdGFuY2UsIGJhc2VQYXRoKSkge1xuICAgIGNsZWFySW5zdGFuY2VTdGF0ZShkZWNvcmF0ZWRJbnN0YW5jZSk7XG4gICAgc2V0SW5zdGFuY2VCYXNlUGF0aChkZWNvcmF0ZWRJbnN0YW5jZSwgYmFzZVBhdGgpO1xuICB9XG5cbiAgaWYgKCFiYXNlUGF0aCkge1xuICAgIHJldHVybiBOZ1JlZHV4Lmluc3RhbmNlO1xuICB9XG5cbiAgY29uc3Qgc3RvcmUgPSBnZXRJbnN0YW5jZVN0b3JlKGRlY29yYXRlZEluc3RhbmNlKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHNldEluc3RhbmNlU3RvcmUoXG4gICAgICBkZWNvcmF0ZWRJbnN0YW5jZSxcbiAgICAgIE5nUmVkdXguaW5zdGFuY2UuY29uZmlndXJlU3ViU3RvcmUoYmFzZVBhdGgsIG9wdGlvbnMubG9jYWxSZWR1Y2VyKSxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGdldEluc3RhbmNlU3RvcmUoZGVjb3JhdGVkSW5zdGFuY2UpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSB0aGUgZ2l2ZW4gc2VsZWN0aW9uIHBhcmFtZXRlcnMsXG4gKiByb290ZWQgYXQgZGVjb3JhdGVkSW5zdGFuY2UncyBzdG9yZSwgYW5kIGNhY2hlcyBpdCBvbiB0aGVcbiAqIGluc3RhbmNlIGZvciBmdXR1cmUgdXNlLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VTZWxlY3Rpb24gPSA8VD4oXG4gIGRlY29yYXRlZEluc3RhbmNlOiBhbnksXG4gIGtleTogc3RyaW5nIHwgc3ltYm9sLFxuICBzZWxlY3RvcjogU2VsZWN0b3I8YW55LCBUPixcbiAgdHJhbnNmb3JtZXI/OiBUcmFuc2Zvcm1lcjxhbnksIFQ+LFxuICBjb21wYXJhdG9yPzogQ29tcGFyYXRvcixcbikgPT4ge1xuICBjb25zdCBzdG9yZSA9IGdldEJhc2VTdG9yZShkZWNvcmF0ZWRJbnN0YW5jZSk7XG5cbiAgaWYgKHN0b3JlKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9IGdldEluc3RhbmNlU2VsZWN0aW9uTWFwKGRlY29yYXRlZEluc3RhbmNlKTtcblxuICAgIHNlbGVjdGlvbnNba2V5XSA9XG4gICAgICBzZWxlY3Rpb25zW2tleV0gfHxcbiAgICAgICghdHJhbnNmb3JtZXJcbiAgICAgICAgPyBzdG9yZS5zZWxlY3Qoc2VsZWN0b3IsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogc3RvcmUuc2VsZWN0KHNlbGVjdG9yKS5waXBlKFxuICAgICAgICAgICAgb2JzJCA9PiB0cmFuc2Zvcm1lcihvYnMkLCBkZWNvcmF0ZWRJbnN0YW5jZSksXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yKSxcbiAgICAgICAgICApKTtcblxuICAgIHJldHVybiBzZWxlY3Rpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbiJdfQ==