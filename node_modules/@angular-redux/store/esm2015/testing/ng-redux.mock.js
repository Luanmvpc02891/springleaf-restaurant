/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: See if this linting rule can be enabled with new build process (ng-packagr)
// tslint:disable:no-implicit-dependencies
// tslint:disable:member-ordering
import { NgRedux, } from '@angular-redux/store';
import { MockObservableStore } from './observable-store.mock';
/**
 * Convenience mock to make it easier to control selector
 * behaviour in unit tests.
 * @template T
 */
export class MockNgRedux extends NgRedux {
    /**
     * @hidden
     */
    constructor() {
        super();
        //
        this.mockRootStore = new MockObservableStore();
        this.configureSubStore = (/** @type {?} */ (this.mockRootStore.configureSubStore));
        this.dispatch = (/** @type {?} */ (this.mockRootStore.dispatch));
        this.getState = (/** @type {?} */ (this.mockRootStore.getState));
        this.subscribe = this.mockRootStore.subscribe;
        this.replaceReducer = this.mockRootStore.replaceReducer;
        this.select = this.mockRootStore.select;
        this.provideStore = (_) => undefined;
        this.configureStore = (_, __, ___, ____) => undefined;
        // This hooks the mock up to @select.
        NgRedux.instance = (/** @type {?} */ (this));
    }
    /**
     * Returns a subject that's connected to any observable returned by the
     * given selector. You can use this subject to pump values into your
     * components or services under test; when they call .select or \@select
     * in the context of a unit test, MockNgRedux will give them the values
     * you pushed onto your stub.
     * @template R, S
     * @param {?=} selector
     * @param {?=} comparator
     * @return {?}
     */
    static getSelectorStub(selector, comparator) {
        return MockNgRedux.getInstance().mockRootStore.getSelectorStub(selector, comparator);
    }
    /**
     * Returns a mock substore that allows you to set up selectorStubs for
     * any 'fractal' stores your app creates with NgRedux.configureSubStore.
     *
     * If your app creates deeply nested substores from other substores,
     * pass the chain of pathSelectors in as ordered arguments to mock
     * the nested substores out.
     * @template S
     * @param {...?} pathSelectors
     * @return {?}
     */
    static getSubStore(...pathSelectors) {
        return pathSelectors.length
            ? MockNgRedux.getInstance().mockRootStore.getSubStore(...pathSelectors)
            : MockNgRedux.getInstance().mockRootStore;
    }
    /**
     * Reset all previously configured stubs.
     * @return {?}
     */
    static reset() {
        MockNgRedux.getInstance().mockRootStore.reset();
        NgRedux.instance = (/** @type {?} */ (MockNgRedux.mockInstance));
    }
    /**
     * Gets the singleton MockNgRedux instance. Useful for cases where your
     * tests need to spy on store methods, for example.
     * @return {?}
     */
    static getInstance() {
        MockNgRedux.mockInstance = MockNgRedux.mockInstance || new MockNgRedux();
        return MockNgRedux.mockInstance;
    }
}
/**
 * @deprecated Use MockNgRedux.getInstance() instead.
 */
MockNgRedux.mockInstance = undefined;
if (false) {
    /**
     * @deprecated Use MockNgRedux.getInstance() instead.
     * @type {?}
     */
    MockNgRedux.mockInstance;
    /**
     * @type {?}
     * @private
     */
    MockNgRedux.prototype.mockRootStore;
    /** @type {?} */
    MockNgRedux.prototype.configureSubStore;
    /** @type {?} */
    MockNgRedux.prototype.dispatch;
    /** @type {?} */
    MockNgRedux.prototype.getState;
    /** @type {?} */
    MockNgRedux.prototype.subscribe;
    /** @type {?} */
    MockNgRedux.prototype.replaceReducer;
    /** @type {?} */
    MockNgRedux.prototype.select;
    /** @type {?} */
    MockNgRedux.prototype.provideStore;
    /** @type {?} */
    MockNgRedux.prototype.configureStore;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcmVkdXgubW9jay5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXJlZHV4L3N0b3JlL3Rlc3RpbmcvIiwic291cmNlcyI6WyJuZy1yZWR1eC5tb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHQSxPQUFPLEVBRUwsT0FBTyxHQUdSLE1BQU0sc0JBQXNCLENBQUM7QUFVOUIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7OztBQUs5RCxNQUFNLE9BQU8sV0FBb0IsU0FBUSxPQUFVOzs7O0lBb0VqRDtRQUNFLEtBQUssRUFBRSxDQUFDOztRQWRGLGtCQUFhLEdBQUcsSUFBSSxtQkFBbUIsRUFBTyxDQUFDO1FBRXZELHNCQUFpQixHQUFHLG1CQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQU8sQ0FBQztRQUNoRSxhQUFRLEdBQUcsbUJBQUEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQWlCLENBQUM7UUFDeEQsYUFBUSxHQUFHLG1CQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFPLENBQUM7UUFDOUMsY0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3pDLG1CQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUM7UUFDbkQsV0FBTSxHQUcwQixJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQztRQVMxRCxpQkFBWSxHQUFHLENBQUMsQ0FBYSxFQUFRLEVBQUUsQ0FBQyxTQUFTLENBQUM7UUFDbEQsbUJBQWMsR0FBRyxDQUNmLENBQTBCLEVBQzFCLEVBQU8sRUFDUCxHQUFrQixFQUNsQixJQUEyQixFQUNyQixFQUFFLENBQUMsU0FBUyxDQUFDO1FBVm5CLHFDQUFxQztRQUNyQyxPQUFPLENBQUMsUUFBUSxHQUFHLG1CQUFBLElBQUksRUFBTyxDQUFDO0lBQ2pDLENBQUM7Ozs7Ozs7Ozs7OztJQTdERCxNQUFNLENBQUMsZUFBZSxDQUNwQixRQUF5QixFQUN6QixVQUF1QjtRQUV2QixPQUFPLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUM1RCxRQUFRLEVBQ1IsVUFBVSxDQUNYLENBQUM7SUFDSixDQUFDOzs7Ozs7Ozs7Ozs7SUFXRCxNQUFNLENBQUMsV0FBVyxDQUNoQixHQUFHLGFBQTZCO1FBRWhDLE9BQU8sYUFBYSxDQUFDLE1BQU07WUFDekIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsYUFBYSxDQUFDO1lBQ3ZFLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsYUFBYSxDQUFDO0lBQzlDLENBQUM7Ozs7O0lBS0QsTUFBTSxDQUFDLEtBQUs7UUFDVixXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hELE9BQU8sQ0FBQyxRQUFRLEdBQUcsbUJBQUEsV0FBVyxDQUFDLFlBQVksRUFBTyxDQUFDO0lBQ3JELENBQUM7Ozs7OztJQU1ELE1BQU0sQ0FBQyxXQUFXO1FBQ2hCLFdBQVcsQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDLFlBQVksSUFBSSxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQ3pFLE9BQU8sV0FBVyxDQUFDLFlBQVksQ0FBQztJQUNsQyxDQUFDOzs7OztBQW5ETSx3QkFBWSxHQUFzQixTQUFTLENBQUM7Ozs7OztJQUFuRCx5QkFBbUQ7Ozs7O0lBcURuRCxvQ0FBdUQ7O0lBRXZELHdDQUFnRTs7SUFDaEUsK0JBQXdEOztJQUN4RCwrQkFBOEM7O0lBQzlDLGdDQUF5Qzs7SUFDekMscUNBQW1EOztJQUNuRCw2QkFHMEQ7O0lBUzFELG1DQUFrRDs7SUFDbEQscUNBS3FCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogU2VlIGlmIHRoaXMgbGludGluZyBydWxlIGNhbiBiZSBlbmFibGVkIHdpdGggbmV3IGJ1aWxkIHByb2Nlc3MgKG5nLXBhY2thZ3IpXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1pbXBsaWNpdC1kZXBlbmRlbmNpZXNcbi8vIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZ1xuaW1wb3J0IHtcbiAgQ29tcGFyYXRvcixcbiAgTmdSZWR1eCxcbiAgUGF0aFNlbGVjdG9yLFxuICBTZWxlY3Rvcixcbn0gZnJvbSAnQGFuZ3VsYXItcmVkdXgvc3RvcmUnO1xuaW1wb3J0IHtcbiAgQW55QWN0aW9uLFxuICBEaXNwYXRjaCxcbiAgTWlkZGxld2FyZSxcbiAgUmVkdWNlcixcbiAgU3RvcmUsXG4gIFN0b3JlRW5oYW5jZXIsXG59IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE1vY2tPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICcuL29ic2VydmFibGUtc3RvcmUubW9jayc7XG4vKipcbiAqIENvbnZlbmllbmNlIG1vY2sgdG8gbWFrZSBpdCBlYXNpZXIgdG8gY29udHJvbCBzZWxlY3RvclxuICogYmVoYXZpb3VyIGluIHVuaXQgdGVzdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2NrTmdSZWR1eDxUID0ge30+IGV4dGVuZHMgTmdSZWR1eDxUPiB7XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgTW9ja05nUmVkdXguZ2V0SW5zdGFuY2UoKSBpbnN0ZWFkLiAqL1xuICBzdGF0aWMgbW9ja0luc3RhbmNlPzogTW9ja05nUmVkdXg8YW55PiA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN1YmplY3QgdGhhdCdzIGNvbm5lY3RlZCB0byBhbnkgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGVcbiAgICogZ2l2ZW4gc2VsZWN0b3IuIFlvdSBjYW4gdXNlIHRoaXMgc3ViamVjdCB0byBwdW1wIHZhbHVlcyBpbnRvIHlvdXJcbiAgICogY29tcG9uZW50cyBvciBzZXJ2aWNlcyB1bmRlciB0ZXN0OyB3aGVuIHRoZXkgY2FsbCAuc2VsZWN0IG9yIEBzZWxlY3RcbiAgICogaW4gdGhlIGNvbnRleHQgb2YgYSB1bml0IHRlc3QsIE1vY2tOZ1JlZHV4IHdpbGwgZ2l2ZSB0aGVtIHRoZSB2YWx1ZXNcbiAgICogeW91IHB1c2hlZCBvbnRvIHlvdXIgc3R1Yi5cbiAgICovXG4gIHN0YXRpYyBnZXRTZWxlY3RvclN0dWI8UiwgUz4oXG4gICAgc2VsZWN0b3I/OiBTZWxlY3RvcjxSLCBTPixcbiAgICBjb21wYXJhdG9yPzogQ29tcGFyYXRvcixcbiAgKTogU3ViamVjdDxTPiB7XG4gICAgcmV0dXJuIE1vY2tOZ1JlZHV4LmdldEluc3RhbmNlKCkubW9ja1Jvb3RTdG9yZS5nZXRTZWxlY3RvclN0dWI8Uz4oXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGNvbXBhcmF0b3IsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbW9jayBzdWJzdG9yZSB0aGF0IGFsbG93cyB5b3UgdG8gc2V0IHVwIHNlbGVjdG9yU3R1YnMgZm9yXG4gICAqIGFueSAnZnJhY3RhbCcgc3RvcmVzIHlvdXIgYXBwIGNyZWF0ZXMgd2l0aCBOZ1JlZHV4LmNvbmZpZ3VyZVN1YlN0b3JlLlxuICAgKlxuICAgKiBJZiB5b3VyIGFwcCBjcmVhdGVzIGRlZXBseSBuZXN0ZWQgc3Vic3RvcmVzIGZyb20gb3RoZXIgc3Vic3RvcmVzLFxuICAgKiBwYXNzIHRoZSBjaGFpbiBvZiBwYXRoU2VsZWN0b3JzIGluIGFzIG9yZGVyZWQgYXJndW1lbnRzIHRvIG1vY2tcbiAgICogdGhlIG5lc3RlZCBzdWJzdG9yZXMgb3V0LlxuICAgKiBAcGFyYW0gcGF0aFNlbGVjdG9yc1xuICAgKi9cbiAgc3RhdGljIGdldFN1YlN0b3JlPFM+KFxuICAgIC4uLnBhdGhTZWxlY3RvcnM6IFBhdGhTZWxlY3RvcltdXG4gICk6IE1vY2tPYnNlcnZhYmxlU3RvcmU8Uz4ge1xuICAgIHJldHVybiBwYXRoU2VsZWN0b3JzLmxlbmd0aFxuICAgICAgPyBNb2NrTmdSZWR1eC5nZXRJbnN0YW5jZSgpLm1vY2tSb290U3RvcmUuZ2V0U3ViU3RvcmUoLi4ucGF0aFNlbGVjdG9ycylcbiAgICAgIDogTW9ja05nUmVkdXguZ2V0SW5zdGFuY2UoKS5tb2NrUm9vdFN0b3JlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBwcmV2aW91c2x5IGNvbmZpZ3VyZWQgc3R1YnMuXG4gICAqL1xuICBzdGF0aWMgcmVzZXQoKTogdm9pZCB7XG4gICAgTW9ja05nUmVkdXguZ2V0SW5zdGFuY2UoKS5tb2NrUm9vdFN0b3JlLnJlc2V0KCk7XG4gICAgTmdSZWR1eC5pbnN0YW5jZSA9IE1vY2tOZ1JlZHV4Lm1vY2tJbnN0YW5jZSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2luZ2xldG9uIE1vY2tOZ1JlZHV4IGluc3RhbmNlLiBVc2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdXJcbiAgICogdGVzdHMgbmVlZCB0byBzcHkgb24gc3RvcmUgbWV0aG9kcywgZm9yIGV4YW1wbGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgTW9ja05nUmVkdXgubW9ja0luc3RhbmNlID0gTW9ja05nUmVkdXgubW9ja0luc3RhbmNlIHx8IG5ldyBNb2NrTmdSZWR1eCgpO1xuICAgIHJldHVybiBNb2NrTmdSZWR1eC5tb2NrSW5zdGFuY2U7XG4gIH1cbiAgLy9cbiAgcHJpdmF0ZSBtb2NrUm9vdFN0b3JlID0gbmV3IE1vY2tPYnNlcnZhYmxlU3RvcmU8YW55PigpO1xuXG4gIGNvbmZpZ3VyZVN1YlN0b3JlID0gdGhpcy5tb2NrUm9vdFN0b3JlLmNvbmZpZ3VyZVN1YlN0b3JlIGFzIGFueTtcbiAgZGlzcGF0Y2ggPSB0aGlzLm1vY2tSb290U3RvcmUuZGlzcGF0Y2ggYXMgRGlzcGF0Y2g8YW55PjtcbiAgZ2V0U3RhdGUgPSB0aGlzLm1vY2tSb290U3RvcmUuZ2V0U3RhdGUgYXMgYW55O1xuICBzdWJzY3JpYmUgPSB0aGlzLm1vY2tSb290U3RvcmUuc3Vic2NyaWJlO1xuICByZXBsYWNlUmVkdWNlciA9IHRoaXMubW9ja1Jvb3RTdG9yZS5yZXBsYWNlUmVkdWNlcjtcbiAgc2VsZWN0OiA8U2VsZWN0ZWRUeXBlPihcbiAgICBzZWxlY3Rvcj86IFNlbGVjdG9yPFQsIFNlbGVjdGVkVHlwZT4sXG4gICAgY29tcGFyYXRvcj86IENvbXBhcmF0b3IsXG4gICkgPT4gT2JzZXJ2YWJsZTxTZWxlY3RlZFR5cGU+ID0gdGhpcy5tb2NrUm9vdFN0b3JlLnNlbGVjdDtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIFRoaXMgaG9va3MgdGhlIG1vY2sgdXAgdG8gQHNlbGVjdC5cbiAgICBOZ1JlZHV4Lmluc3RhbmNlID0gdGhpcyBhcyBhbnk7XG4gIH1cblxuICBwcm92aWRlU3RvcmUgPSAoXzogU3RvcmU8YW55Pik6IHZvaWQgPT4gdW5kZWZpbmVkO1xuICBjb25maWd1cmVTdG9yZSA9IChcbiAgICBfOiBSZWR1Y2VyPGFueSwgQW55QWN0aW9uPixcbiAgICBfXzogYW55LFxuICAgIF9fXz86IE1pZGRsZXdhcmVbXSxcbiAgICBfX19fPzogU3RvcmVFbmhhbmNlcjxhbnk+W10sXG4gICk6IHZvaWQgPT4gdW5kZWZpbmVkO1xufVxuIl19